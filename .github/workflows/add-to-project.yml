name: Add issue to Project Backlog

on:
  issues:
    types: [opened]
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Run diagnostics only (no add)?"
        required: false
        default: "false"

# Observação: o acesso de escrita ao Project v2 é feito via PROJECT_TOKEN (PAT).
# As permissões abaixo se aplicam ao GITHUB_TOKEN apenas e são mantidas mínimas.
permissions:
  issues: read
  repository-projects: write

jobs:
  add-to-project-backlog:
    runs-on: ubuntu-latest
    steps:
      - name: Add issue to Project v2 Backlog
        uses: actions/github-script@v6
        env:
          # Número e ID do Project v2
          PROJECT_NUMBER: "21"
          PROJECT_ID: "PVT_kwDOCV9Tw84BF9Ag"
          # Dono do projeto (org ou user) - sobrescreve o owner detectado do repositório
          PROJECT_OWNER: "austv-minecraft"
          # PAT com permissões adequadas (project, repo, read:org)
          PROJECT_TOKEN: ${{ secrets.PROJECT_TOKEN }}
        with:
          script: |
            // 1) Validar payload
            const issueNodeId = context.payload.issue?.node_id;
            if (!issueNodeId) {
              core.setFailed('Issue node_id not found in payload.');
              return;
            }

            // 2) Validar disponibilidade do PAT
            const token = process.env.PROJECT_TOKEN;
            if (!token) {
              core.setFailed('PROJECT_TOKEN secret is not set. Provide a PAT with project/repo/read:org.');
              return;
            }
            console.log('PROJECT_TOKEN present: true');
            console.log('Token length:', token.length);
            console.log('Token prefix:', token.substring(0, 7) + '...');
            console.log('Token suffix:', '...' + token.substring(token.length - 4));

            // 2.1) Diagnóstico: identidade do PAT via GraphQL
            try {
              const viewerRes = await github.request('POST /graphql', {
                headers: { authorization: `token ${token}` },
                data: JSON.stringify({ query: 'query { viewer { login id } }' })
              });
              const viewer = viewerRes?.data?.data?.viewer;
              console.log('PAT viewer.login:', viewer?.login || 'unknown');
              console.log('PAT viewer.id:', viewer?.id || 'unknown');
              
              if (viewer?.login === 'github-actions[bot]') {
                console.log('⚠️ WARNING: Using GITHUB_TOKEN instead of PROJECT_TOKEN!');
                console.log('This means the PROJECT_TOKEN secret is not being read correctly.');
                console.log('Possible causes:');
                console.log('1. Secret not saved in repository settings');
                console.log('2. Organization-level secret overriding repository secret');
                console.log('3. Secret name mismatch (check spelling)');
              }
            } catch (e) {
              console.log('Warning: viewer query failed:', e.message);
            }

            // 3) Preparar GraphQL usando o PAT (esquema 'token' em vez de 'bearer')
            async function gql(query, variables = {}) {
              try {
                const response = await github.request('POST /graphql', {
                  headers: { authorization: `token ${token}` },
                  data: JSON.stringify({ query, variables })
                });
                
                if (response.data.errors && response.data.errors.length) {
                  console.log('GraphQL errors:', JSON.stringify(response.data.errors, null, 2));
                  throw new Error(response.data.errors[0].message || 'GraphQL error');
                }
                
                return response.data;
              } catch (error) {
                console.log('GraphQL request failed:', error.message);
                throw error;
              }
            }

            // 4) Resolver ProjectV2 por ID (fornecido)
            let projectId = process.env.PROJECT_ID;
            if (!projectId) {
              core.setFailed('PROJECT_ID not provided.');
              return;
            }

            (async () => {
              try {
                // Preflight: projeto existe e é ProjectV2? Se não, tentar fallback por owner + number
                let projNode;
                try {
                  const projCheck = await gql(
                    'query($id:ID!){ node(id:$id){ __typename ... on ProjectV2 { id title } } }',
                    { id: projectId }
                  );
                  projNode = projCheck?.data?.node;
                  if (!projNode || projNode.__typename !== 'ProjectV2') {
                    throw new Error(`PROJECT_ID did not resolve to ProjectV2. Got: ${projNode?.__typename || 'null'}`);
                  }
                } catch (preErr) {
                  console.log(`Preflight by id failed: ${preErr.message || preErr}`);
                  // Fallback: tentar resolver pelo owner do repositório + PROJECT_NUMBER
                  const owner = process.env.PROJECT_OWNER || context.payload.repository?.owner?.login || context.repo.owner;
                  const number = parseInt(process.env.PROJECT_NUMBER || '0', 10);
                  if (!owner || !Number.isInteger(number) || number <= 0) {
                    throw new Error('Fallback requires valid owner and PROJECT_NUMBER.');
                  }
                  console.log(`Trying fallback lookup: owner=${owner}, number=${number}`);
                  
                  // Tentar buscar via lista de projetos da organização
                  const listQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 100) {
                          nodes {
                            id
                            title
                            number
                          }
                        }
                      }
                    }
                  `;
                  
                  const listRes = await gql(listQuery, { owner });
                  const orgProjects = listRes?.data?.organization?.projectsV2?.nodes || [];
                  console.log(`Found ${orgProjects.length} projects in org`);
                  
                  const found = orgProjects.find(p => p.number === number);
                  
                  if (!found) {
                    const projectTitles = orgProjects.map(p => `#${p.number}: ${p.title}`).join(', ');
                    throw new Error(`Could not find Project v2 #${number} under ${owner}. Available projects: ${projectTitles || 'none visible to PAT'}. Ensure: (1) PAT user is org member, (2) SSO authorized if applicable, (3) user added to Project v2 with Write permission.`);
                  }
                  
                  console.log(`Discovered via org projects list: ${found.title} (#${found.number}) -> ${found.id}`);
                  projNode = { __typename: 'ProjectV2', id: found.id, title: found.title };
                  projectId = found.id;
                }
                console.log('Target ProjectV2:', projNode.title, `(#${process.env.PROJECT_NUMBER})`, projectId);

                // Se rodando como dry-run, termine após diagnosticar o projeto
                const dryRun = (core.getInput('dry_run') || process.env.DRY_RUN || 'false').toString().toLowerCase() === 'true';
                if (dryRun) {
                  console.log('Dry-run enabled; skipping add and status update.');
                  return;
                }

                // Preflight: conteúdo é Issue?
                const contentCheck = await gql(
                  'query($id:ID!){ node(id:$id){ __typename id } }',
                  { id: issueNodeId }
                );
                const ctype = contentCheck?.data?.node?.__typename;
                if (ctype !== 'Issue') {
                  throw new Error(`Content type must be Issue; got ${ctype || 'null'}`);
                }

                // 5) Adicionar item ao Project v2
                const addRes = await gql(
                  'mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item{ id } } }',
                  { projectId, contentId: issueNodeId }
                );
                const itemId = addRes?.data?.addProjectV2ItemById?.item?.id;
                if (!itemId) throw new Error('Project item was not created.');
                console.log('Item added to project:', itemId);

                // 6) Tentar setar o status "Backlog" (se existir como Single Select)
                const fieldsRes = await gql(
                  'query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { fields(first:100){ nodes{ __typename id name ... on ProjectV2SingleSelectField { options { id name } } } } } } }',
                  { projectId }
                );
                const nodes = fieldsRes?.data?.node?.fields?.nodes || [];
                let targetFieldId = null;
                let targetOptionId = null;
                for (const f of nodes) {
                  if (f.__typename === 'ProjectV2SingleSelectField' && Array.isArray(f.options)) {
                    const opt = f.options.find(o => o.name && o.name.toLowerCase() === 'backlog');
                    if (opt) { targetFieldId = f.id; targetOptionId = opt.id; break; }
                  }
                }

                if (targetFieldId && targetOptionId) {
                  const setRes = await gql(
                    'mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:ID!){ updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{singleSelectOptionId:$optionId}}){ projectV2Item{ id } } }',
                    { projectId, itemId, fieldId: targetFieldId, optionId: targetOptionId }
                  );
                  console.log('Backlog status set:', JSON.stringify(setRes));
                } else {
                  console.log('Backlog option not found; item remains in default state.');
                }

                console.log('Success: Issue added to ProjectV2 (and Backlog if available).');
              } catch (e) {
                core.setFailed(`Failed to add issue to ProjectV2: ${e.message || e}. If this mentions not resolving the project: ensure the PAT user is a member of the org, has SSO authorized, and has at least Write access to the target Project v2. Also confirm the project is Project v2 and PROJECT_NUMBER/ID are correct.`);
              }
            })();
