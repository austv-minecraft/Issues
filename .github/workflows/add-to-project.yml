name: Add issue to Project Backlog

on:
  issues:
    types: [opened]

# Observação: o acesso de escrita ao Project v2 é feito via PROJECT_TOKEN (PAT).
# As permissões abaixo se aplicam ao GITHUB_TOKEN apenas e são mantidas mínimas.
permissions:
  issues: read
  contents: read

jobs:
  add-to-project-backlog:
    runs-on: ubuntu-latest
    steps:
      - name: Add issue to Project v2 Backlog
        uses: actions/github-script@v6
        env:
          # Número e ID do Project v2
          PROJECT_NUMBER: '21'
          PROJECT_ID: 'PVT_kwDOCV9Tw84BF9Ag'
          # PAT com permissões adequadas (project, repo, read:org)
          PROJECT_TOKEN: ${{ secrets.PROJECT_TOKEN }}
        with:
          script: |
            const core = require('@actions/core');

            // 1) Validar payload
            const issueNodeId = context.payload.issue?.node_id;
            if (!issueNodeId) {
              core.setFailed('Issue node_id not found in payload.');
              return;
            }

            // 2) Validar disponibilidade do PAT
            const tokenPresent = !!process.env.PROJECT_TOKEN;
            console.log('PROJECT_TOKEN present?', tokenPresent);
            if (!tokenPresent) {
              core.setFailed('PROJECT_TOKEN secret is not set. Provide a PAT with project/repo/read:org.');
              return;
            }

            // 3) Preparar GraphQL usando o PAT
            async function gql(query, variables) {
              const res = await github.request({
                method: 'POST',
                url: 'https://api.github.com/graphql',
                headers: {
                  authorization: `bearer ${process.env.PROJECT_TOKEN}`,
                  'content-type': 'application/json'
                },
                data: { query, variables }
              });
              const data = res.data;
              if (data.errors && data.errors.length) {
                console.log('GraphQL errors:', JSON.stringify(data.errors));
                throw new Error(data.errors[0].message || 'GraphQL error');
              }
              return data;
            }

            // 4) Resolver ProjectV2 por ID (fornecido)
            const projectId = process.env.PROJECT_ID;
            if (!projectId) {
              core.setFailed('PROJECT_ID not provided.');
              return;
            }

            (async () => {
              try {
                // Preflight: projeto existe e é ProjectV2?
                const projCheck = await gql(
                  'query($id:ID!){ node(id:$id){ __typename ... on ProjectV2 { id title } } }',
                  { id: projectId }
                );
                const projNode = projCheck?.data?.node;
                if (!projNode || projNode.__typename !== 'ProjectV2') {
                  throw new Error(`PROJECT_ID did not resolve to ProjectV2. Got: ${projNode?.__typename || 'null'}`);
                }
                console.log('Target ProjectV2:', projNode.title, `(#${process.env.PROJECT_NUMBER})`, projectId);

                // Preflight: conteúdo é Issue?
                const contentCheck = await gql(
                  'query($id:ID!){ node(id:$id){ __typename id } }',
                  { id: issueNodeId }
                );
                const ctype = contentCheck?.data?.node?.__typename;
                if (ctype !== 'Issue') {
                  throw new Error(`Content type must be Issue; got ${ctype || 'null'}`);
                }

                // 5) Adicionar item ao Project v2
                const addRes = await gql(
                  'mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item{ id } } }',
                  { projectId, contentId: issueNodeId }
                );
                const itemId = addRes?.data?.addProjectV2ItemById?.item?.id;
                if (!itemId) throw new Error('Project item was not created.');
                console.log('Item added to project:', itemId);

                // 6) Tentar setar o status "Backlog" (se existir como Single Select)
                const fieldsRes = await gql(
                  'query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { fields(first:100){ nodes{ __typename id name ... on ProjectV2SingleSelectField { options { id name } } } } } } }',
                  { projectId }
                );
                const nodes = fieldsRes?.data?.node?.fields?.nodes || [];
                let targetFieldId = null;
                let targetOptionId = null;
                for (const f of nodes) {
                  if (f.__typename === 'ProjectV2SingleSelectField' && Array.isArray(f.options)) {
                    const opt = f.options.find(o => o.name && o.name.toLowerCase() === 'backlog');
                    if (opt) { targetFieldId = f.id; targetOptionId = opt.id; break; }
                  }
                }

                if (targetFieldId && targetOptionId) {
                  const setRes = await gql(
                    'mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:ID!){ updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{singleSelectOptionId:$optionId}}){ projectV2Item{ id } } }',
                    { projectId, itemId, fieldId: targetFieldId, optionId: targetOptionId }
                  );
                  console.log('Backlog status set:', JSON.stringify(setRes));
                } else {
                  console.log('Backlog option not found; item remains in default state.');
                }

                console.log('Success: Issue added to ProjectV2 (and Backlog if available).');
              } catch (e) {
                core.setFailed(`Failed to add issue to ProjectV2: ${e.message || e}`);
              }
            })();