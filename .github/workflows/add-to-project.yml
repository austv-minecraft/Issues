name: Add issue to Project Backlog

on:
  issues:
    types: [opened]
  workflow_dispatch:
    inputs:
      dry_run:
        description: "Run diagnostics only (no add)?"
        required: false
        default: "false"

# Observação: o acesso de escrita ao Project v2 é feito via PROJECT_TOKEN (PAT).
# As permissões abaixo se aplicam ao GITHUB_TOKEN apenas e são mantidas mínimas.
permissions:
  issues: read
  repository-projects: write

jobs:
  add-to-project-backlog:
    runs-on: ubuntu-latest
    steps:
      - name: Add issue to Project v2 Backlog
        uses: actions/github-script@v6
        env:
          # Número e ID do Project v2
          PROJECT_NUMBER: "21"
          PROJECT_ID: "PVT_kwDOCV9Tw84BF9Ag"
          # Dono do projeto (org ou user) - sobrescreve o owner detectado do repositório
          PROJECT_OWNER: "austv-minecraft"
          # PAT com permissões adequadas (project, repo, read:org)
          PROJECT_TOKEN: ${{ secrets.PROJECT_TOKEN }}
        with:
          script: |
            // 1) Validar payload
            const issueNodeId = context.payload.issue?.node_id;
            if (!issueNodeId) {
              core.setFailed('Issue node_id not found in payload.');
              return;
            }

            // 2) Validar disponibilidade do PAT
            const tokenPresent = !!process.env.PROJECT_TOKEN;
            console.log('PROJECT_TOKEN present?', tokenPresent);
            if (!tokenPresent) {
              core.setFailed('PROJECT_TOKEN secret is not set. Provide a PAT with project/repo/read:org.');
              return;
            }

            // 2.1) Diagnóstico: identidade do PAT e escopos OAuth
            try {
              const who = await github.request('GET /user', {
                headers: { authorization: `bearer ${process.env.PROJECT_TOKEN}` }
              });
              const viewerLogin = who?.data?.login;
              const scopes = who?.headers?.['x-oauth-scopes'] || who?.headers?.['X-OAuth-Scopes'];
              console.log(`PAT viewer.login: ${viewerLogin || 'unknown'}`);
              console.log(`PAT OAuth scopes: ${scopes || 'unknown'}`);
            } catch (e) {
              console.log('Warning: could not query /user with PAT for diagnostics:', e.message || e);
            }

            // 3) Preparar GraphQL usando o PAT
            async function gql(query, variables) {
              const res = await github.request({
                method: 'POST',
                url: 'https://api.github.com/graphql',
                headers: {
                  authorization: `bearer ${process.env.PROJECT_TOKEN}`,
                  'content-type': 'application/json'
                },
                data: { query, variables }
              });
              const data = res.data;
              if (data.errors && data.errors.length) {
                console.log('GraphQL errors:', JSON.stringify(data.errors));
                throw new Error(data.errors[0].message || 'GraphQL error');
              }
              return data;
            }

            // 4) Resolver ProjectV2 por ID (fornecido)
            let projectId = process.env.PROJECT_ID;
            if (!projectId) {
              core.setFailed('PROJECT_ID not provided.');
              return;
            }

            (async () => {
              try {
                // Preflight: projeto existe e é ProjectV2? Se não, tentar fallback por owner + number
                let projNode;
                try {
                  const projCheck = await gql(
                    'query($id:ID!){ node(id:$id){ __typename ... on ProjectV2 { id title } } }',
                    { id: projectId }
                  );
                  projNode = projCheck?.data?.node;
                  if (!projNode || projNode.__typename !== 'ProjectV2') {
                    throw new Error(`PROJECT_ID did not resolve to ProjectV2. Got: ${projNode?.__typename || 'null'}`);
                  }
                } catch (preErr) {
                  console.log(`Preflight by id failed: ${preErr.message || preErr}`);
                  // Fallback: tentar resolver pelo owner do repositório + PROJECT_NUMBER
                  const owner = process.env.PROJECT_OWNER || context.payload.repository?.owner?.login || context.repo.owner;
                  const number = parseInt(process.env.PROJECT_NUMBER || '0', 10);
                  if (!owner || !Number.isInteger(number) || number <= 0) {
                    throw new Error('Fallback requires valid owner and PROJECT_NUMBER.');
                  }
                  console.log(`Trying fallback lookup: owner=${owner}, number=${number}`);
                  const fb = await gql(
                    'query($owner:String!,$number:Int!){\n                      organization(login:$owner){ project(number:$number){ id name } projectV2(number:$number){ id title number } projectsV2(first:100){ nodes{ id title number } } }\n                      user(login:$owner){ projectV2(number:$number){ id title number } }\n                    }',
                    { owner, number }
                  );
                  const orgProj = fb?.data?.organization?.projectV2;
                  const userProj = fb?.data?.user?.projectV2;
                  const orgClassic = fb?.data?.organization?.project;
                  let found = orgProj || userProj;
                  if (!found) {
                    const orgList = fb?.data?.organization?.projectsV2?.nodes || [];
                    const byNumber = orgList.find(p => p?.number === number);
                    if (byNumber) {
                      console.log(`Discovered via org projects list: ${byNumber.title} (#${byNumber.number}) -> ${byNumber.id}`);
                      found = byNumber;
                    }
                  }
                  if (!found) {
                    if (orgClassic?.id) {
                      throw new Error(`Project #${number} under ${owner} appears to be a Classic project (GraphQL type Project). This workflow targets Project v2 only. Migrate to Projects (v2) or create a new Project v2 and update PROJECT_NUMBER/ID.`);
                    }
                    throw new Error(`Could not resolve ProjectV2 by owner+number. Ensure project #${number} exists under ${owner}, PAT user can see the org and the project (org membership + SSO), and the PAT user is added to the Project v2 with Write. Also confirm the repo owner matches the project owner or set PROJECT_OWNER explicitly.`);
                  }
                  projNode = { __typename: 'ProjectV2', id: found.id, title: found.title };
                  if (projectId !== found.id) {
                    console.log(`Notice: discovered project id differs from provided PROJECT_ID. Using discovered id: ${found.id}`);
                    projectId = found.id;
                  }
                }
                console.log('Target ProjectV2:', projNode.title, `(#${process.env.PROJECT_NUMBER})`, projectId);

                // Se rodando como dry-run, termine após diagnosticar o projeto
                const dryRun = (core.getInput('dry_run') || process.env.DRY_RUN || 'false').toString().toLowerCase() === 'true';
                if (dryRun) {
                  console.log('Dry-run enabled; skipping add and status update.');
                  return;
                }

                // Preflight: conteúdo é Issue?
                const contentCheck = await gql(
                  'query($id:ID!){ node(id:$id){ __typename id } }',
                  { id: issueNodeId }
                );
                const ctype = contentCheck?.data?.node?.__typename;
                if (ctype !== 'Issue') {
                  throw new Error(`Content type must be Issue; got ${ctype || 'null'}`);
                }

                // 5) Adicionar item ao Project v2
                const addRes = await gql(
                  'mutation($projectId:ID!,$contentId:ID!){ addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}){ item{ id } } }',
                  { projectId, contentId: issueNodeId }
                );
                const itemId = addRes?.data?.addProjectV2ItemById?.item?.id;
                if (!itemId) throw new Error('Project item was not created.');
                console.log('Item added to project:', itemId);

                // 6) Tentar setar o status "Backlog" (se existir como Single Select)
                const fieldsRes = await gql(
                  'query($projectId:ID!){ node(id:$projectId){ ... on ProjectV2 { fields(first:100){ nodes{ __typename id name ... on ProjectV2SingleSelectField { options { id name } } } } } } }',
                  { projectId }
                );
                const nodes = fieldsRes?.data?.node?.fields?.nodes || [];
                let targetFieldId = null;
                let targetOptionId = null;
                for (const f of nodes) {
                  if (f.__typename === 'ProjectV2SingleSelectField' && Array.isArray(f.options)) {
                    const opt = f.options.find(o => o.name && o.name.toLowerCase() === 'backlog');
                    if (opt) { targetFieldId = f.id; targetOptionId = opt.id; break; }
                  }
                }

                if (targetFieldId && targetOptionId) {
                  const setRes = await gql(
                    'mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:ID!){ updateProjectV2ItemFieldValue(input:{projectId:$projectId, itemId:$itemId, fieldId:$fieldId, value:{singleSelectOptionId:$optionId}}){ projectV2Item{ id } } }',
                    { projectId, itemId, fieldId: targetFieldId, optionId: targetOptionId }
                  );
                  console.log('Backlog status set:', JSON.stringify(setRes));
                } else {
                  console.log('Backlog option not found; item remains in default state.');
                }

                console.log('Success: Issue added to ProjectV2 (and Backlog if available).');
              } catch (e) {
                core.setFailed(`Failed to add issue to ProjectV2: ${e.message || e}. If this mentions not resolving the project: ensure the PAT user is a member of the org, has SSO authorized, and has at least Write access to the target Project v2. Also confirm the project is Project v2 and PROJECT_NUMBER/ID are correct.`);
              }
            })();
