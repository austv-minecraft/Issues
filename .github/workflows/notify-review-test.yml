name: Notify Discord on Review/Test

on:
  # Verificar a cada 5 minutos se h√° issues em Review/Test n√£o notificadas
  schedule:
    - cron: "*/5 * * * *"
  # Tamb√©m permite execu√ß√£o manual
  workflow_dispatch:

permissions:
  issues: write
  repository-projects: read

jobs:
  check-and-notify:
    runs-on: ubuntu-latest
    steps:
      - name: Check Project Status and Notify Discord
        uses: actions/github-script@v6
        env:
          PROJECT_NUMBER: "21"
          PROJECT_ID: "PVT_kwDOCV9Tw84BF9Ag"
          PROJECT_OWNER: "austv-minecraft"
          MY_PAT_TOKEN: ${{ secrets.GH_PROJECT_PAT || secrets.PROJECT_TOKEN || secrets.PROJECTS_TOKEN }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_REVIEW_TEST || secrets.DISCORD_WEBHOOK_URL }}
          DISCORD_ROLE_ID: ${{ secrets.DISCORD_REVIEW_ROLE_ID || secrets.DISCORD_ROLE_ID }}
        with:
          github-token: ${{ secrets.GH_PROJECT_PAT || secrets.PROJECT_TOKEN || secrets.PROJECTS_TOKEN }}
          script: |
            console.log('=== Iniciando verifica√ß√£o de issues em Review/Test ===\n');

            // 1) Validar disponibilidade do PAT
            const token = process.env.MY_PAT_TOKEN;
            if (!token) {
              core.setFailed('MY_PAT_TOKEN secret is not set. Provide GH_PROJECT_PAT, PROJECT_TOKEN or PROJECTS_TOKEN with project/repo/read:org permissions.');
              return;
            }
            console.log('‚úì PAT Token present');

            // 2) Diagn√≥stico: identidade do PAT
            try {
              const viewerRes = await github.request('POST /graphql', {
                headers: { authorization: `token ${token}` },
                data: JSON.stringify({ query: 'query { viewer { login id } }' })
              });
              const viewer = viewerRes?.data?.data?.viewer;
              console.log('‚úì PAT viewer.login:', viewer?.login || 'unknown');
              
              if (viewer?.login === 'github-actions[bot]') {
                core.setFailed('ERRO: Usando GITHUB_TOKEN ao inv√©s de PROJECT_TOKEN! Configure o secret GH_PROJECT_PAT.');
                return;
              }
            } catch (e) {
              console.log('Warning: viewer query failed:', e.message);
            }

            // 3) Preparar fun√ß√£o GraphQL
            async function gql(query, variables = {}) {
              try {
                const response = await github.request('POST /graphql', {
                  headers: { authorization: `token ${token}` },
                  data: JSON.stringify({ query, variables })
                });
                
                if (response.data.errors && response.data.errors.length) {
                  console.log('GraphQL errors:', JSON.stringify(response.data.errors, null, 2));
                  throw new Error(response.data.errors[0].message || 'GraphQL error');
                }
                
                return response.data;
              } catch (error) {
                console.log('GraphQL request failed:', error.message);
                throw error;
              }
            }

            // 4) Fun√ß√£o para enviar notifica√ß√£o ao Discord usando exec
            async function sendDiscordNotification(issue, status) {
              const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
              if (!webhookUrl) {
                console.log('‚ö†Ô∏è DISCORD_WEBHOOK_URL n√£o configurado.');
                return false;
              }
              
              const roleId = process.env.DISCORD_ROLE_ID;
              const roleMention = roleId ? `<@&${roleId}>` : '@here';
              
              const payload = {
                content: `${roleMention} Nova issue para revis√£o/teste!`,
                embeds: [{
                  title: `üîç ${issue.title}`,
                  url: issue.url,
                  description: `Issue #${issue.number} foi movida para **${status}**`,
                  color: 65280,
                  fields: [
                    {
                      name: 'Autor',
                      value: issue.author || 'Desconhecido',
                      inline: true
                    },
                    {
                      name: 'Status',
                      value: status,
                      inline: true
                    }
                  ],
                  footer: {
                    text: `${context.repo.owner}/${context.repo.repo}`
                  },
                  timestamp: new Date().toISOString()
                }]
              };
              
              try {
                const payloadJson = JSON.stringify(payload);
                
                await exec.exec('curl', [
                  '-H', 'Content-Type: application/json',
                  '-d', payloadJson,
                  webhookUrl
                ], {
                  silent: false,
                  ignoreReturnCode: false
                });
                
                console.log(`‚úÖ Notifica√ß√£o enviada para Discord - Issue #${issue.number}`);
                return true;
              } catch (error) {
                console.log(`‚ùå Erro ao enviar notifica√ß√£o para Discord - Issue #${issue.number}:`, error.message);
                return false;
              }
            }

            // 5) Resolver ProjectV2 por ID
            let projectId = process.env.PROJECT_ID;
            if (!projectId) {
              core.setFailed('PROJECT_ID not provided.');
              return;
            }

            (async () => {
              try {
                console.log('\n=== Verificando Projeto ===');
                
                // Preflight: projeto existe e √© ProjectV2?
                let projNode;
                try {
                  const projCheck = await gql(
                    'query($id:ID!){ node(id:$id){ __typename ... on ProjectV2 { id title number } } }',
                    { id: projectId }
                  );
                  projNode = projCheck?.data?.node;
                  if (!projNode || projNode.__typename !== 'ProjectV2') {
                    throw new Error(`PROJECT_ID did not resolve to ProjectV2. Got: ${projNode?.__typename || 'null'}`);
                  }
                } catch (preErr) {
                  console.log(`Preflight by id failed: ${preErr.message}`);
                  
                  // Fallback: buscar por owner + number
                  const owner = process.env.PROJECT_OWNER || context.repo.owner;
                  const number = parseInt(process.env.PROJECT_NUMBER || '0', 10);
                  
                  console.log(`Tentando fallback: owner=${owner}, number=${number}`);
                  
                  const listQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 100) {
                          nodes {
                            id
                            title
                            number
                          }
                        }
                      }
                    }
                  `;
                  
                  const listRes = await gql(listQuery, { owner });
                  const orgProjects = listRes?.data?.organization?.projectsV2?.nodes || [];
                  console.log(`Found ${orgProjects.length} projects in org`);
                  
                  const found = orgProjects.find(p => p.number === number);
                  
                  if (!found) {
                    const projectTitles = orgProjects.map(p => `#${p.number}: ${p.title}`).join(', ');
                    throw new Error(`Could not find Project v2 #${number} under ${owner}. Available: ${projectTitles || 'none'}`);
                  }
                  
                  console.log(`‚úì Discovered: ${found.title} (#${found.number})`);
                  projNode = found;
                  projectId = found.id;
                }
                
                console.log(`‚úì Target Project: ${projNode.title} (#${projNode.number})`);

                // 6) Buscar TODOS os itens do projeto
                console.log('\n=== Buscando Issues no Projeto ===');
                
                const itemsQuery = `
                  query($projectId: ID!) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        items(first: 100) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                id
                                number
                                title
                                url
                                author {
                                  login
                                }
                                labels(first: 20) {
                                  nodes {
                                    name
                                  }
                                }
                              }
                            }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldSingleSelectValue {
                                  name
                                  optionId
                                  field {
                                    ... on ProjectV2SingleSelectField {
                                      id
                                      name
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                
                const itemsRes = await gql(itemsQuery, { projectId });
                const items = itemsRes?.data?.node?.items?.nodes || [];
                
                console.log(`Total de itens no projeto: ${items.length}`);
                
                // 7) Processar cada item e verificar se est√° em Review/Test
                let issuesProcessed = 0;
                let issuesNotified = 0;
                
                for (const item of items) {
                  if (!item.content || !item.content.number) {
                    continue; // N√£o √© uma issue
                  }
                  
                  issuesProcessed++;
                  const issue = item.content;
                  const issueNumber = issue.number;
                  
                  // VERIFICA√á√ÉO DUPLA: Buscar labels diretamente da API para garantir dados atualizados
                  let issueLabels = [];
                  try {
                    const issueData = await github.rest.issues.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber
                    });
                    issueLabels = issueData.data.labels.map(l => l.name);
                    console.log(`Issue #${issueNumber} - Labels atuais: [${issueLabels.join(', ')}]`);
                  } catch (e) {
                    console.log(`‚ö†Ô∏è Erro ao buscar labels da issue #${issueNumber}:`, e.message);
                    // Fallback para labels do GraphQL
                    issueLabels = (issue.labels?.nodes || []).map(l => l.name);
                  }
                  
                  const fieldValues = item.fieldValues?.nodes || [];
                  
                  // Buscar status atual
                  let currentStatus = null;
                  for (const fieldValue of fieldValues) {
                    const fieldName = fieldValue.field?.name || '';
                    const valueName = fieldValue.name || '';
                    
                    if (fieldName.toLowerCase().includes('status') || 
                        fieldName.toLowerCase().includes('estado')) {
                      currentStatus = valueName;
                      break;
                    }
                  }
                  
                  if (!currentStatus) {
                    continue; // Sem status definido
                  }
                  
                  // Verificar se est√° em Review/Test
                  const statusLower = currentStatus.toLowerCase();
                  const isReviewTest = statusLower.includes('review') && statusLower.includes('test');
                  
                  if (!isReviewTest) {
                    continue; // N√£o est√° em Review/Test
                  }
                  
                  // Verificar se j√° foi notificado (usando labels atualizadas)
                  const alreadyNotified = issueLabels.includes('üîî notificado-review');
                  
                  if (alreadyNotified) {
                    console.log(`  Issue #${issueNumber} - J√° notificada (pulando)`);
                    continue;
                  }
                  
                  // Issue em Review/Test e n√£o notificada
                  console.log(`\nüéØ Issue #${issueNumber} encontrada em Review/Test (n√£o notificada)`);
                  console.log(`   T√≠tulo: ${issue.title}`);
                  console.log(`   Status: ${currentStatus}`);
                  
                  // ADICIONAR LABEL ANTES de enviar notifica√ß√£o (prevenir duplicatas)
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      labels: ['üîî notificado-review']
                    });
                    console.log(`   ‚úì Label "üîî notificado-review" adicionada (PR√â-ENVIO)`);
                    
                    // Pequeno delay para garantir que a label foi adicionada
                    await new Promise(resolve => setTimeout(resolve, 1000));
                  } catch (e) {
                    console.log(`   ‚ö†Ô∏è N√£o foi poss√≠vel adicionar label:`, e.message);
                    console.log(`   ‚ö†Ô∏è Pulando envio para evitar duplicatas`);
                    continue; // Se n√£o conseguir adicionar label, n√£o enviar notifica√ß√£o
                  }
                  
                  // Agora enviar notifica√ß√£o
                  const issueData = {
                    number: issueNumber,
                    title: issue.title,
                    url: issue.url,
                    author: issue.author?.login
                  };
                  
                  const sent = await sendDiscordNotification(issueData, currentStatus);
                  
                  if (sent) {
                    issuesNotified++;
                    console.log(`   ‚úì Notifica√ß√£o enviada com sucesso`);
                  } else {
                    // Se falhou ao enviar, remover a label para tentar novamente depois
                    console.log(`   ‚ö†Ô∏è Falha ao enviar notifica√ß√£o, removendo label para retry`);
                    try {
                      await github.rest.issues.removeLabel({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        name: 'üîî notificado-review'
                      });
                    } catch (e) {
                      // Ignorar erro ao remover
                    }
                  }
                }
                
                console.log('\n=== Resumo ===');
                console.log(`Issues processadas: ${issuesProcessed}`);
                console.log(`Notifica√ß√µes enviadas: ${issuesNotified}`);
                console.log('=== Finalizado ===');
                
              } catch (e) {
                core.setFailed(`Failed to check project status: ${e.message || e}`);
                console.log('Stack trace:', e.stack);
              }
            })();
