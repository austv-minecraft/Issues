name: Notify Discord on Review/Test

on:
  issues:
    types: [opened, reopened, edited, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to check (for manual testing)"
        required: false

permissions:
  issues: read
  repository-projects: read

jobs:
  check-and-notify:
    runs-on: ubuntu-latest
    steps:
      - name: Check Project Status and Notify Discord
        uses: actions/github-script@v6
        env:
          PROJECT_NUMBER: "21"
          PROJECT_ID: "PVT_kwDOCV9Tw84BF9Ag"
          PROJECT_OWNER: "austv-minecraft"
          MY_PAT_TOKEN: ${{ secrets.GH_PROJECT_PAT || secrets.PROJECT_TOKEN || secrets.PROJECTS_TOKEN }}
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_REVIEW_TEST || secrets.DISCORD_WEBHOOK_URL }}
          DISCORD_ROLE_ID: ${{ secrets.DISCORD_REVIEW_ROLE_ID || secrets.DISCORD_ROLE_ID }}
        with:
          github-token: ${{ secrets.GH_PROJECT_PAT || secrets.PROJECT_TOKEN || secrets.PROJECTS_TOKEN }}
          script: |
            // 1) Validar payload e obter informa√ß√µes da issue
            const issueNumber = core.getInput('issue_number') || context.payload.issue?.number;
            const issueNodeId = context.payload.issue?.node_id;
            const issueTitle = context.payload.issue?.title;
            const issueUrl = context.payload.issue?.html_url;
            const issueAuthor = context.payload.issue?.user?.login;

            if (!issueNumber) {
              console.log('Issue number not found in payload.');
              return;
            }

            console.log(`\n=== Processando Issue #${issueNumber} ===`);
            console.log(`T√≠tulo: ${issueTitle}`);
            console.log(`Autor: ${issueAuthor}`);
            console.log(`URL: ${issueUrl}`);

            // 2) Validar disponibilidade do PAT
            const token = process.env.MY_PAT_TOKEN;
            if (!token) {
              core.setFailed('MY_PAT_TOKEN secret is not set. Provide GH_PROJECT_PAT, PROJECT_TOKEN or PROJECTS_TOKEN with project/repo/read:org permissions.');
              return;
            }
            console.log('‚úì PAT Token present');

            // 2.1) Diagn√≥stico: identidade do PAT
            try {
              const viewerRes = await github.request('POST /graphql', {
                headers: { authorization: `token ${token}` },
                data: JSON.stringify({ query: 'query { viewer { login id } }' })
              });
              const viewer = viewerRes?.data?.data?.viewer;
              console.log('‚úì PAT viewer.login:', viewer?.login || 'unknown');
              
              if (viewer?.login === 'github-actions[bot]') {
                core.warning('WARNING: Using GITHUB_TOKEN instead of PROJECT_TOKEN! The workflow may not have access to project data.');
              }
            } catch (e) {
              console.log('Warning: viewer query failed:', e.message);
            }

            // 3) Preparar fun√ß√£o GraphQL
            async function gql(query, variables = {}) {
              try {
                const response = await github.request('POST /graphql', {
                  headers: { authorization: `token ${token}` },
                  data: JSON.stringify({ query, variables })
                });
                
                if (response.data.errors && response.data.errors.length) {
                  console.log('GraphQL errors:', JSON.stringify(response.data.errors, null, 2));
                  throw new Error(response.data.errors[0].message || 'GraphQL error');
                }
                
                return response.data;
              } catch (error) {
                console.log('GraphQL request failed:', error.message);
                throw error;
              }
            }

            // 4) Fun√ß√£o para enviar notifica√ß√£o ao Discord
            async function sendDiscordNotification(status) {
              const webhookUrl = process.env.DISCORD_WEBHOOK_URL;
              if (!webhookUrl) {
                console.log('‚ö†Ô∏è DISCORD_WEBHOOK_URL n√£o configurado.');
                return false;
              }
              
              const roleId = process.env.DISCORD_ROLE_ID;
              const roleMention = roleId ? `<@&${roleId}>` : '@here';
              
              const payload = {
                content: `${roleMention} Nova issue para revis√£o/teste!`,
                embeds: [{
                  title: `üîç ${issueTitle}`,
                  url: issueUrl,
                  description: `Issue #${issueNumber} foi movida para **${status}**`,
                  color: 0x00ff00,
                  fields: [
                    {
                      name: 'Autor',
                      value: issueAuthor || 'Desconhecido',
                      inline: true
                    },
                    {
                      name: 'Status',
                      value: status,
                      inline: true
                    }
                  ],
                  footer: {
                    text: `${context.repo.owner}/${context.repo.repo}`
                  },
                  timestamp: new Date().toISOString()
                }]
              };
              
              try {
                const fetch = (await import('node-fetch')).default;
                const response = await fetch(webhookUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                  const errorText = await response.text();
                  throw new Error(`Discord webhook failed: ${response.status} ${response.statusText} - ${errorText}`);
                }
                
                console.log('‚úÖ Notifica√ß√£o enviada para Discord com sucesso!');
                return true;
              } catch (error) {
                console.log('‚ùå Erro ao enviar notifica√ß√£o para Discord:', error.message);
                return false;
              }
            }

            // 5) Resolver ProjectV2 por ID
            let projectId = process.env.PROJECT_ID;
            if (!projectId) {
              core.setFailed('PROJECT_ID not provided.');
              return;
            }

            (async () => {
              try {
                console.log('\n=== Verificando Projeto ===');
                
                // Preflight: projeto existe e √© ProjectV2?
                let projNode;
                try {
                  const projCheck = await gql(
                    'query($id:ID!){ node(id:$id){ __typename ... on ProjectV2 { id title number } } }',
                    { id: projectId }
                  );
                  projNode = projCheck?.data?.node;
                  if (!projNode || projNode.__typename !== 'ProjectV2') {
                    throw new Error(`PROJECT_ID did not resolve to ProjectV2. Got: ${projNode?.__typename || 'null'}`);
                  }
                } catch (preErr) {
                  console.log(`Preflight by id failed: ${preErr.message}`);
                  
                  // Fallback: buscar por owner + number
                  const owner = process.env.PROJECT_OWNER || context.repo.owner;
                  const number = parseInt(process.env.PROJECT_NUMBER || '0', 10);
                  
                  console.log(`Tentando fallback: owner=${owner}, number=${number}`);
                  
                  const listQuery = `
                    query($owner: String!) {
                      organization(login: $owner) {
                        projectsV2(first: 100) {
                          nodes {
                            id
                            title
                            number
                          }
                        }
                      }
                    }
                  `;
                  
                  const listRes = await gql(listQuery, { owner });
                  const orgProjects = listRes?.data?.organization?.projectsV2?.nodes || [];
                  console.log(`Found ${orgProjects.length} projects in org`);
                  
                  const found = orgProjects.find(p => p.number === number);
                  
                  if (!found) {
                    const projectTitles = orgProjects.map(p => `#${p.number}: ${p.title}`).join(', ');
                    throw new Error(`Could not find Project v2 #${number} under ${owner}. Available: ${projectTitles || 'none'}`);
                  }
                  
                  console.log(`‚úì Discovered: ${found.title} (#${found.number})`);
                  projNode = found;
                  projectId = found.id;
                }
                
                console.log(`‚úì Target Project: ${projNode.title} (#${projNode.number})`);

                // 6) Buscar item da issue no projeto
                console.log('\n=== Buscando Issue no Projeto ===');
                
                const itemsQuery = `
                  query($projectId: ID!, $issueNodeId: ID!) {
                    node(id: $projectId) {
                      ... on ProjectV2 {
                        items(first: 100) {
                          nodes {
                            id
                            content {
                              ... on Issue {
                                id
                                number
                              }
                            }
                            fieldValues(first: 20) {
                              nodes {
                                ... on ProjectV2ItemFieldSingleSelectValue {
                                  name
                                  optionId
                                  field {
                                    ... on ProjectV2SingleSelectField {
                                      id
                                      name
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                `;
                
                const itemsRes = await gql(itemsQuery, { projectId, issueNodeId });
                const items = itemsRes?.data?.node?.items?.nodes || [];
                
                console.log(`Total de itens no projeto: ${items.length}`);
                
                // Encontrar o item correspondente
                const item = items.find(i => i.content?.number === issueNumber);
                
                if (!item) {
                  console.log(`‚ö†Ô∏è Issue #${issueNumber} n√£o encontrada no projeto.`);
                  console.log('A issue precisa estar adicionada ao projeto para verificar seu status.');
                  return;
                }
                
                console.log(`‚úì Issue encontrada no projeto! Item ID: ${item.id}`);

                // 7) Verificar campos e status
                console.log('\n=== Verificando Status ===');
                
                const fieldValues = item.fieldValues?.nodes || [];
                console.log(`Campos encontrados: ${fieldValues.length}`);
                
                let currentStatus = null;
                let statusFieldName = null;
                
                for (const fieldValue of fieldValues) {
                  const fieldName = fieldValue.field?.name || '';
                  const valueName = fieldValue.name || '';
                  
                  console.log(`  Campo: "${fieldName}" = "${valueName}"`);
                  
                  // Procurar por campo de Status
                  if (fieldName.toLowerCase().includes('status') || 
                      fieldName.toLowerCase().includes('estado')) {
                    currentStatus = valueName;
                    statusFieldName = fieldName;
                    console.log(`  ‚Ü≥ ‚úì Campo de status identificado!`);
                  }
                }
                
                if (!currentStatus) {
                  console.log('‚ö†Ô∏è Campo de status n√£o encontrado para esta issue.');
                  return;
                }
                
                console.log(`\nStatus atual: "${currentStatus}"`);
                
                // 8) Verificar se est√° em Review/Test
                const statusLower = currentStatus.toLowerCase();
                const isReviewTest = statusLower.includes('review') && statusLower.includes('test');
                
                if (isReviewTest) {
                  console.log('\nüéØ Issue est√° em Review/Test!');
                  
                  // Verificar se j√° foi notificado (label)
                  const labels = context.payload.issue?.labels || [];
                  const alreadyNotified = labels.some(l => l.name === 'üîî notificado-review');
                  
                  if (alreadyNotified && context.eventName !== 'workflow_dispatch') {
                    console.log('‚ÑπÔ∏è Notifica√ß√£o j√° enviada anteriormente (label presente).');
                    return;
                  }
                  
                  // Enviar notifica√ß√£o
                  const sent = await sendDiscordNotification(currentStatus);
                  
                  if (sent) {
                    // Adicionar label para evitar duplicatas
                    try {
                      await github.rest.issues.addLabels({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issueNumber,
                        labels: ['üîî notificado-review']
                      });
                      console.log('‚úì Label "üîî notificado-review" adicionada.');
                    } catch (e) {
                      console.log('‚ö†Ô∏è N√£o foi poss√≠vel adicionar label:', e.message);
                    }
                  }
                } else {
                  console.log(`\n‚ÑπÔ∏è Issue n√£o est√° em Review/Test.`);
                  console.log(`   Status atual: "${currentStatus}"`);
                  
                  // Remover label se existir
                  try {
                    await github.rest.issues.removeLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issueNumber,
                      name: 'üîî notificado-review'
                    });
                    console.log('‚úì Label "üîî notificado-review" removida.');
                  } catch (e) {
                    // Label n√£o existe, ignorar
                  }
                }
                
                console.log('\n=== Finalizado ===');
                
              } catch (e) {
                core.setFailed(`Failed to check project status: ${e.message || e}`);
                console.log('Stack trace:', e.stack);
              }
            })();
